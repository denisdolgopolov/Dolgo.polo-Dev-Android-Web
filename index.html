<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Dolgo.polo Dev</title>
    <meta content="width=device-width, initial-scale=1" name="viewport" />
    <link rel="stylesheet" href="styles.css?v=2" type="text/css">
    <link rel="shortcut icon" href="favicon.png" type="image/png">
</head>
<body>

    <div class="container_main">
        <div class="header_container">
            <img id="logo" src="logo.svg" class="logo"/>

            <div class="title">Это сайт об<br> android<br> разработке.</div>
        </div>

        <div class="finding">
            <input id="input" type="text" name="123" placeholder="Введите любое слово. Попробуем что-нибудь найти">
            <span id="b_clear" class="icon"></span>
        </div>

        <div id="container_posts">
<div class="container_post">
        <a href="https://t.me/dolgo_polo_dev/14">
          <img class="post_img" src="imgs/14.jpg" onerror="this.src='imgs/not_found.png';">
          <h4 class="post_title"><b>Негласные правила в названиях</b></h4>
          <p class="post_desc">
Называть классы можно как угодно, но со временем каждый разработчик приходит к одним и тем же ключевым словам, которые на удивление очень точно описывают содержание файла:

Base -> класс, описывающий переменные и функции, которые понадобятся всем его наследникам. Причем это настолько удобно, что при открытии пустого проекта первым делом создаю классы вроде BaseFragment, BaseActivity, BaseRepository... и унаследуюсь от них, просто на всякий случай

Utils -> штука, которая делает какие-нибудь технические операции над данными. Например, конвертируем таймстамп в дату

Manager -> сюда скидываем все, что непонятно куда девать еще

Api (обычно), Service (реже) -> описание запросов к серверу

Repository, Data, Container, Source -> источник данных

Listener, Callback -> класс, который описывает функции, которые будут вызываться при возникновении события

какие еще штампы забыл?</p>
        </a>
      </div>

<div class="container_post">
        <a href="https://t.me/dolgo_polo_dev/15">
          <img class="post_img" src="imgs/15.jpg" onerror="this.src='imgs/not_found.png';">
          <h4 class="post_title"><b>Отличие onStart() от onResume()</b></h4>
          <p class="post_desc">
onStart - вызывается, когда вьюшка (активити\фрагмент) выводится на экран. при этом вьюшка может быть чем-та перекрыта, например, всплывающим диалогом или шторкой. 
пользовать видит часть экрана, но пользоваться им не может (т.к. ему нужно сначала закрыть диалог\убрать шторку)

onResume - вызывается, когда у пользователя открыт и ничем не перекрыт экран, то есть он может с ним беспрепятственно взаимодействовать 

p.s. при этом onStart будет вызван перед onResume, даже если экран не перекрыт. но полный контакт с пользователем есть только после onResume</p>
        </a>
      </div>

<div class="container_post">
        <a href="https://t.me/dolgo_polo_dev/18">
          <img class="post_img" src="imgs/18.jpg" onerror="this.src='imgs/not_found.png';">
          <h4 class="post_title"><b>​​Dependency Injection на пальцах (DI, Dagger, Hilt, Koin)</b></h4>
          <p class="post_desc">
Долго боялся лезть разбираться в том, что же такое внедрение зависимостей. Но оказалось все очень просто - все библиотеки делают одно и то же:
Выносят создание класса в отдельный файл

Если раньше вы писали: SomeManager variable = new SomeManager();

прямо там, где вам нужен был этот менеджер, то теперь будете писать: @Inject SomeManager variable;

а для создания класса SomeManager напишите одну функцию, которая будет вызываться автоматически:
SomeManager provide() { return new SomeManager(); }

Зачем? 
1. Чтобы заменив в одном месте параметры создания класса, сразу заменить их везде
2. Чтобы каждый раз не писать new SomeManager(), достаточно аннотации
3. Чтобы легко заменить класс SomeManager на SomeManager2, внеся изменения только в одном месте
4. Чтобы легче было отслеживать жизненный цикл этого объекта (большинство библиотек умеют создавать\уничтожать объект самостоятельно, привязываясь к жизненному циклу класса, в который был инъецирован объект)
5. Чтобы управлять количеством созданных копий. Например, если SomeManager используется в десяти разных местах одной активити, то можно с помощью одной аннотации указать, что во всех этих местах должен использоваться один и тот же экземпляр SomeManager, а не создаваться новые. А вот в другой активити уже будет создан независимый экземпляр SomeManager. И вам не придется следить за этим самостоятельно

какие еще плюшки от DI можно получить и какие минусы он тащит за собой?</p>
        </a>
      </div>

<div class="container_post">
        <a href="https://t.me/dolgo_polo_dev/19">
          <img class="post_img" src="imgs/19.jpg" onerror="this.src='imgs/not_found.png';">
          <h4 class="post_title"><b>.aab (.AAB)  — что и зачем </b></h4>
          <p class="post_desc">
как и .apk, новый формат .aab - это архив, содержащий все файлы (код, ресурсы) приложения 

разница следующая: 

— если вы отдаете в плей маркет .apk, то пользователю придется скачать этот файл со всеми ресурсами, включая те, которые на его устройстве использоваться не будут 

например, вы в ресурсы положили картинку в шести разрешениях (mdpi, hdpi, xhdpi...). а у пользователя разрешение hdpi, но скачать ему придется все 6 картинок, и только потом телефон сможет удалить лишнее 

— если отдаете .aab, то гугл, перед тем как отдать пользователю apk, сам выкинет лишние картинки, и отдаст только нужное 

эта оптимизация позволяет уменьшить вес АПК для пользователя на 8-50% 

а степень уменьшения веса зависит от количества ресурсов, дублирующих друг друга под разные устройства


теперь вопрос к залу: почему гугл не может просто вырезать лишние ресурсы из апшки?</p>
        </a>
      </div>

<div class="container_post">
        <a href="https://t.me/dolgo_polo_dev/20">
          <img class="post_img" src="imgs/20.jpg" onerror="this.src='imgs/not_found.png';">
          <h4 class="post_title"><b>​​Да кто этот ваш Context</b></h4>
          <p class="post_desc">
Самая загадочная и покрытая тайнами, как говорит молодежь, дичь в андроиде — Context  Используется на каждом шагу, а с лету написать определение не так уж просто

Но если не ударяться в философию, то Context - это класс, который обеспечивает доступ из одной части приложения (кода) к другой (ресурсам). 
Получив context, вы заполучаете методы для считывания картинок, строковых ресурсов и всего остального, запиханного в ваш apk

А еще кто-то сильно подумал и решил, что он же будет отвечать за навигацию (запуск активитей) и работу фоновых служб (сервисов и бродкастов), то есть за взаимодействие приложения с системой

Позже кто-то не расслышал про "ни при каких условиях не создавать God-классы" и назначил контекст ответственным за работу с SharedPreference. Ну и за коннект со внутренними и внешними файлами заодно

Но в целом есть короткий ответ: context - прокладка между кодом приложения и остальной системой

Вопрос с собеса на джуна: почему нельзя передавать контекст, полученный методами getContext()\getActivity\Activity.this куда попало?</p>
        </a>
      </div>

<div class="container_post">
        <a href="https://t.me/dolgo_polo_dev/21">
          <img class="post_img" src="imgs/21.jpg" onerror="this.src='imgs/not_found.png';">
          <h4 class="post_title"><b>​​Волшебство LiveData</b></h4>
          <p class="post_desc">
LiveData - это класс, работающий по принципу Observable. 
Поэтому сначала вспомним, какими функциями занимается  Observable-класс:

1. Хранит объект какого-то типа. Например, Observable<Integer> - хранит объект типа Integer
2. Может получать новый объект. Например, вот так: Observable .post(123)  //готово, мы отдали на хранение новый объект типа Integer
3. Может отдавать всем подписчикам хранимый объект. Подписаться на такой Observable можно в любом месте, вызвав Observable.observe()

Обычно Observable нужен для такого сценария:

1. Создаем новый Observable
2. Подписываемся на него в десяти местах
3. Отдаем Observable новое значение на хранение
4. Observable передает в эти десять мест полученное значение

То есть мы снимаем с себя головную боль по поводу того, как из одного места прокинуть новое значение в десять мест

А теперь пару строк, ради которых вы дочитали предисловие: 

LiveData - прокаченный Observable. Его крутость в том, что он следит за жизненным циклом подписчиков, и отсылает данные только живым подписчикам.

Например, подписались мы на Observable в активити. Через пять минут в Observable поступили новые данные, он их отправляет в активити — а она то сдохла!

И приложение падает. А LiveData этого бы не сделала. 
LiveData отправляет данные, только если подписанный класс находится в состоянии onStart() или onResume(). В противном случае просто хранит данные до тех пор, пока подписанный класс не проснется или не появится новый подписчик</p>
        </a>
      </div>

<div class="container_post">
        <a href="https://t.me/dolgo_polo_dev/22">
          <img class="post_img" src="imgs/22.jpg" onerror="this.src='imgs/not_found.png';">
          <h4 class="post_title"><b>​​Главная цель архитектуры или зачем столько страданий</b></h4>
          <p class="post_desc">
Можно выкупить принципы всех архитектур, так и не поняв, зачем столько геморроя © Аристотель, 300кк век до н. э.

Маленькие приложения могут прожить без архитектуры. Первые 5-7 приложений я написал, совершенно не задумываясь о потребности в строгом паттерне.  Каждая статья про архитектуру мобильного приложения рождала мысль: "И зачем это усложнение - будем писать в три раза больше кода, чтобы код стал понятнее, вы серьезно?"

А потом начались проекты c десятками тысяч строк. И мне показалось, что понял, зачем нужны MVC, MVVM, MVI, MVP... "Чтобы разносить код приложения в разные классы и модули! Чтобы знать, где что лежит, не открывая файл! Чтобы не плодить God-objects!" - воскликнул наивно

На самом деле нет

Все эти преимущества можно обеспечить и без архитектуры. Создавай кучу классов, придерживайся правил составления имен, — готово

Основная цель любой архитектуры — обеспечить однонаправленный поток данных

Каждый из подходов позволяет сделать так, чтобы у нас был всего один поток данных: из недр приложения (источника данных like база данных\сервер) к пользователю.
При этом в видимой части приложения (UI) могут родиться только события, которые пойдут параллельно данным, но в обратную сторону

Архитектуры спасают нас от ветвления, запрещают нам создавать и изменять данные вне определенного потока, чтобы мы всегда могли пройти по хлебным крошкам и найти, на каком этапе пути (а не макаронного дерева) произошла ошибка

Теперь можно выбирать на практике самую близкую душе архитектуру, понимая их философское значение</p>
        </a>
      </div>

<div class="container_post">
        <a href="https://t.me/dolgo_polo_dev/23">
          <img class="post_img" src="imgs/23.jpg" onerror="this.src='imgs/not_found.png';">
          <h4 class="post_title"><b>​​Каналы уведомлений </b></h4>
          <p class="post_desc">
Начиная с версии Android 8 (API 26), перед тем как вывести любое уведомление в шторку, нужно создать Notification Channel (далее - канал), а после этого указать channelId при создании объекта Notification (собстна, самого уведомления) 

Каналы нужны для того, чтобы пользователь мог в настройках (Приложения -> О приложении -> Уведомления) отключить только ненужные сообщения от приложения 

И это чертовски удобно. Например, я отключил все каналы от Вконтакте, кроме тех, что отвечают за оповещение о новых сообщениях 

Поэтому, работая с уведомлениями, нужно продумать, на какие логические блоки можно разбить все ваши нотификации, и дать каналам понятные пользователю имена</p>
        </a>
      </div>

<div class="container_post">
        <a href="https://t.me/dolgo_polo_dev/24">
          <img class="post_img" src="imgs/24.jpg" onerror="this.src='imgs/not_found.png';">
          <h4 class="post_title"><b>​​Общая ViewModel </b></h4>
          <p class="post_desc">
Не самая очевидная вещь: один экземпляр ViewModel может быть доступен из нескольких фрагментов или активитей 

Например, вам нужна аватарка пользователя в двух фрагментах

Вы можете: 
— для каждого фрагмента создать свою ViewModel и прописать в них обоих одинаковую логику получения аватарки. При этом в каждой из этих вьюМоделей будет своя MutableLiveData<Bitmap>, хранящая картинку

— создать одну вьюМодел и получить к ней доступ из обоих фрагментов

Фокус в том, что вьюМодел хранится у кого-то. И этот кто-то - ViewModelStoreOwner. Владельцем (Owner) могут быть: 
- фрагменты
- активити
- кастомные классы, реализующие интерфейс ViewModelStoreOwner (редкий кейс)

Хранитель вьюМодели определяется во время получения ее экземпляра через ViewModelStoreProvider(ViewModelStoreOwner owner)

Так вот, если в качестве владельца передать не сам фрагмент, а его родительскую активити, то хранить экземпляр вьюМодел будет активити. А доступ к этой активити есть и у второго фрагмента из нашего примера. Значит, когда он захочет получить вьюМодель через ViewModelStoreProvider(getActvivityy()), то он получит тот же экземпляр вьюМодели, с которым работал первый фрагмент (то есть там уже будет лежать аватарка)

Знать об этом способе стоит, но хороший ли это подход с точки зрения архитектуры и памяти?</p>
        </a>
      </div>

<div class="container_post">
        <a href="https://t.me/dolgo_polo_dev/25">
          <img class="post_img" src="imgs/25.jpg" onerror="this.src='imgs/not_found.png';">
          <h4 class="post_title"><b>​​Style vs Theme </b></h4>
          <p class="post_desc">
Если вы копируете код, чтобы вставить его в другом месте, задумайтесь. Что-то вы делаете не так 

Это касается и xml-разметки. Одинаковые параметры вьюшек нужно выносить в файл styles.xml и ссылаться на них с помощью android:theme="" или style=""

Сначала их одинаковые черты: 

и theme, и style — мапа (набор ключ-значений), где:
• ключ - название атрибута 
• значение - цвет, размер, форма, тип (например, inputType) или ссылка на файл с ресурсами, где лежит конкретное значение 

Теперь различие: 

• Style — перечисленные атрибуты применяются только к той вью, к которой применен style 

• Theme — перечисленные атрибуты применяются не только к той вью, к которой применена тема, но и ко всем её дочерним вьюшками 

Например, если вы примените theme на уровне приложение (укажите в манифесте), то все активити, вьюГруппы и вьюшки будут брать значения оттуда 

Если примените theme к ViewGroup (Linear, Relative...), то и сама вьюГруппа, и все её наследники будут брать значения оттуда. При этом все древо родителей об этих значениях не узнают

когда лучше использовать одно, а когда второе?</p>
        </a>
      </div>

<div class="container_post">
        <a href="https://t.me/dolgo_polo_dev/26">
          <img class="post_img" src="imgs/26.jpg" onerror="this.src='imgs/not_found.png';">
          <h4 class="post_title"><b>​​minSdkVersion vs targetSdkVersion</b></h4>
          <p class="post_desc">
В файле build.gradle уровня приложения можно указать оба значения. Разница в них следующая:

• minSdkVersion — указывает минимальную версию Android (а точнее version Android SDK Platform API), на которую можно будет установить приложение

Например, при разработке вы заметили, что используете функцию, которая появилась только с Android API 20. Если не установить minSdkVersion = 20, то у пользователей на более ранних версиях приложение будет падать на месте вызове несуществующей в их версии функции 

• targetSdkVersion — указывает версию Android SDK, фишки который вы, как разработчик, полностью оттестировали

Например, в версии 23 (Android 6.0) переработали систему разрешений (permissions): раньше все разрешения приложение должно было запросить в процессе установки. Начиная с SDK 23, разрешения запрашиваются во время работы приложения

Получается, все приложения, не обновленные разработчиками после выхода Android 6.0, должны падать с ошибкой Runtime Permission, так как во время выполнения приложения разрешения в коде не проверяются?

Нет, падать они не будут. В них установлен targetSdkVersion < 23, а это значит, что система сделает для них исключение и даст им работать по старым правилам (то есть им будет достаточно получить разрешения во время установки приложения)

....

Если с этими все понятно, то что такое maxSdkVersion и compileSdkVersion?

Почему стоит следить за обновлением targetSdkVersion или почему не стоит оставаться на старых версиях?</p>
        </a>
      </div>

<div class="container_post">
        <a href="https://t.me/dolgo_polo_dev/27">
          <img class="post_img" src="imgs/27.jpg" onerror="this.src='imgs/not_found.png';">
          <h4 class="post_title"><b>​​Начинаем выполнять ТЗ в четыре раза быстрее, а в освободившееся время чилим </b></h4>
          <p class="post_desc">
Рутинный код пишется в несколько раз быстрее, если использовать следующие хот-кеи (о существовании которых почему-то студия не рассказывает большими красными буквами при первом старте):

Alt + Enter — вызывает бесполезное контекстное меню. но пару функций в нём маст хев:

• если вызвать меню, поставив курсор на строку, то первым пунктом будет Extract string resource (позволяет переместить строку в файл strings. xml, где ей и место) 
• если вызвать на приватном поле, то предложит сгенерировать геттер и сеттер 
• если вызвать на фигурных скобках, в которые обернута только одна строка, то сможете быстро удалить эти фигурные скобки

выделить код + Ctrl + Alt + V — создает переменную и присваивает ей выделенное значение

выделить код + Ctrl + Alt + M — создать функцию и вынести в неё выделенные строки кода 

Shift + F6 — переименовать переменную, функцию, класс... вызвать можно в любом месте, студия переименует элемент во всех местах 

Ctrl + Alt + O — удалить все неиспользуемые импорты из текущего файла 

Ctrl + O — показать список методов, которые можно имплементировать или переопределить 

Ctrl + клик мыши — переход к исходникам (к классу, функции, переменной...)

Ctrl + F — поиск по файлу

двойное нажатие Shift — поиск по всему проекту (поиск файлов, классов, функций...)

....

какими ещё хоткеями вы экономике себе время на дополнительную серию сериальчика?</p>
        </a>
      </div>

<div class="container_post">
        <a href="https://t.me/dolgo_polo_dev/29">
          <img class="post_img" src="imgs/29.jpg" onerror="this.src='imgs/not_found.png';">
          <h4 class="post_title"><b>​​Hash\хэш-код\хэш-функция\хэширование</b></h4>
          <p class="post_desc">
Если вы понимаете, что такое хэш, то гарантированно знаете, как работают: хэш-функции, хэш-таблицы, хэш-мапы, сравнения

Хэш — число, которое однозначно идентифицирует объект, опираясь на заранее придуманные правила сравнения (вольная интерпретация автора, в википедии другие слова)

• хэшем может быть id, если мы заранее договоримся о том, что два объекта точно равны, если равны их id

• хэшем может быть поле name (или любое другое поле), приведенное к числу, если договоримся, что два объекта точно равны, если равны их поля name

• хэшем может быть timestamp создания объекта, сумма всех его полей... почти всё что угодно)

Главное — решить, что в вашей бизнес-логике "равно". Чаще всего "равно" = "у обоих объектов все поля равны" или "равно" = "у обоих объектов равны поля id"

...

В Java у всех классов есть функция hashCode (определена в родительском классе Object).  Что для нее "равно"? (для каких объектов вернет одинаковых хэш)

Чем отличается hashCode в Kotlin у классов, помеченных как data class

Проблема коллизий хэш-функции — о чем она и чем опасна?</p>
        </a>
      </div>

<div class="container_post">
        <a href="https://t.me/dolgo_polo_dev/30">
          <img class="post_img" src="imgs/30.jpg" onerror="this.src='imgs/not_found.png';">
          <h4 class="post_title"><b>​​Где стоит создавать слушатели для элементов RecyclerView — onCreateViewHolder vs onBindViewHolder</b></h4>
          <p class="post_desc">
У каждого ViewHolder может быть одна или несколько кнопок, на которых будут висеть листенеры (onClick, onTouch, а может и что-то потяжелее) 

Пойдём от противного — почему не стоит выставлять слушатели в onBindViewHolder:

• как известно, в onBindViewHolder приходит holder, в котором лежит view, которая переиспользуется для разных элементов списка. получается, вы каждый раз будете создавать новый объект листенера и вешать его на вьюху, у которой уже есть листенер. создаем лишний объект — теряем память, теряем время 

• в onBindViewHolder приходит position, которая есть у холдера в момент байндинга. А что если элемент будет перемещен, допустим,  в следствие Drag-and-drop от пользователя? 
onBindViewHolder заново вызван не будет, а position изменилось

значит, правильно создавать и вешать слушатель в onCreateViewHolder, получая position через holder.getAdapterPosition() внутри слушателя 

также стоит проверять getAdapterPosition() != RecyclerView.NOPOSITION:
 
position = -1 = NOPOSITION, когда RecyclerView проводит перерасчет позиции холдера (в связи с перемещением\удалением\смещением)

....

также существуют методы:

• getAbsoluteAdapterPosition()
• getBindingAdapterPosition()
• getLayoutPosition()
• getPosition() 

в чем между ними разница?</p>
        </a>
      </div>

<div class="container_post">
        <a href="https://t.me/dolgo_polo_dev/31">
          <img class="post_img" src="imgs/31.jpg" onerror="this.src='imgs/not_found.png';">
          <h4 class="post_title"><b>​​Handler & Looper</b></h4>
          <p class="post_desc">
Когда речь заходит о многопоточности, почти все статьи забывают рассказать о том, как главному потоку (aka main thread) удается не заканчиваться 

Ведь любой Thread выполняет метод run() и после этого останавливается! MainThread не исключение!

Значит, в методе run главного потока крутится бесконечный while(true), в теле которого раз за разом проверяются все события, происходит отрисовка графики и прочие штуки, которые мы выполняем в главном потоке

Так оно и есть, только немного (много) сложнее и скрыто за абстракциями:

• Looper (Looper.prepare(), Looper.loop(), Looper.quit()) — создает в методе run бесконечный цикл, который не позволяет потоку "закончиться"

• MessageQueue — очередь, в которую складываются приходящие команды. На каждой итерации бесконечного цикла из очереди будут выниматься команды и выполняться

• Handler — забирает команду (Message) из вашего кода и кладет ее в MessageQueue

вы можете закольцевать любой поток, использовав эти механизмы 

....

сколько циклов в секунду должен успевать делать Looper главного потока, чтобы приложением можно было пользоваться с комфортом (без просадки кадров в секунду)?</p>
        </a>
      </div>

<div class="container_post">
        <a href="https://t.me/dolgo_polo_dev/32">
          <img class="post_img" src="imgs/32.jpg" onerror="this.src='imgs/not_found.png';">
          <h4 class="post_title"><b>​​background / backgroundTint / backgroundTintMode vs tint / tintMode</b></h4>
          <p class="post_desc">
Овладев этими параметрами View, вы перестанете хранить несколько экземпляров иконок, покрашенных в разные цвета, и сэкономите время на создании одинаковых по форме, но отличающихся по цвету drawable-ресурсов

• android:background = цвет, картинка, иконка, фигура или селектор, описанный в xml-файле 

• android:backgroundTint = цвет, который будет накладываться на background 

• android:backgroundTintMode = способ смешения цветов

Например, выбрав tintMode, можно определить, будут ли смешиваться альфа-каналы (прозрачность) заданного цвета и ресурса из background. 
Также можно задать tintMode, который позволит полностью игнорировать исходный цвет ресурса, заданного в поле background. 

Но перекрашивать можно не только background. Например, можно менять цвет ресурса, заданного атрибутом android:src 

В этом случае нам понадобятся:

android:tint — цвет, который будет накладываться на src
android:tintMode — способ смешения цветов

Если минимальная версия sdk не позволяет использовать эти атрибуты, можно установить их через библиотеку AppCompat — достаточно заменить префикс android на app (например, app:tintMode)

Вывод: не стоит дублировать ресурсы одной формы — можно хранить их в одном экземпляре, например, черного цвета, а там где нужно — перекрашивать его</p>
        </a>
      </div>

<div class="container_post">
        <a href="https://t.me/dolgo_polo_dev/33">
          <img class="post_img" src="imgs/33.jpg" onerror="this.src='imgs/not_found.png';">
          <h4 class="post_title"><b>​​MVVM — архитектура за 100 слов</b></h4>
          <p class="post_desc">(Model - View - ViewModel)

Расширение поста — https://t.me/dolgo_polo_dev/22

• View — умеет только отображать данные, которые приходят из ViewModel

Обычно View - это Activity или Fragment

View подписывается на LiveData-объекты, которые лежат во ViewModel — когда данные приходят, она их отображает (никак не обрабатывая!)

View передает события (Actions - клики, тачи, вводы тексты...) во ViewModel

• Model — на самом деле Model Source (источник данных, Repository или же Database)

умеет принимать запрос на данные от ViewModel, получать их (с сервера или локального хранилища)  и отдавать обратно во ViewModel

• ViewModel — прослойка между View и Model. Умеет:
     • принимать события (Actions) от View и реагировать на них
     • запрашивать данные у Model
     • делать бизнес-логику - обрабатывать данные, трансформировать и соединять их
     • отдавать данные во View через объекты LiveData (MutableLiveData)</p>
        </a>
      </div>

<div class="container_post">
        <a href="https://t.me/dolgo_polo_dev/34">
          <img class="post_img" src="imgs/34.jpg" onerror="this.src='imgs/not_found.png';">
          <h4 class="post_title"><b>​​Как воруется платный контент </b></h4>
          <p class="post_desc">
Если вы допустите эту ошибку, то любой гений, готовый потратить вечер на хакерство, сможет собрать крякнутую версию вашего приложения с доступом ко всем платным фичам

Не стоит:
• хранить информацию о купленном контенте локально 
• проверять доступ к контенту исключительно отдельным запросом к серверу

Почему не стоит или как проводится атака:

1) из установленного приложения вытаскивается apk-архив 

2) dex-файлы с кодом перегоняются в smali-код 
smali код более читабельный для человека, чем dex

3) в коде находится строчка, в которой проверяется доступ к платному контенту 
то есть строчка с if(userHasAccess()) 
и меняется на строчку if(true) или просто удаляется

4) измененный код собирается обратно в apk-файл

5) новый apk подписывается и устанавливается на устройство 
а также рассылается всем друзьям)

Как избежать:
единственный известный мне способ — пнуть бек-разработчика, чтобы он на своей стороне всегда проверял, можно ли этому пользователю отдать контент на запрос от приложения

сервер должен относиться к приложению как к штуке, которая может попытаться его наебать

например, если от приложения приходит запрос на прослушивание аудиокниги, то сервер должен проверить, купил ли пользователь эту книгу

....

о каких еще способах воровства вам известно?</p>
        </a>
      </div>

<div class="container_post">
        <a href="https://t.me/dolgo_polo_dev/35">
          <img class="post_img" src="imgs/35.jpg" onerror="this.src='imgs/not_found.png';">
          <h4 class="post_title"><b>​​AudioFocus — как правильно издать звук </b></h4>
          <p class="post_desc">
Мы этого практически не замечаем, но в телефоне достаточно много типов свистоперделок — музыка, уведомления, звонки, будильник, короткие звуки в приложениях (редко, но иногда анимации в приложениях озвучивают), фоновая музыка в играх и звуки, связанные с событиями в игре 

Весь этот музыкальный мусор может воспроизводиться параллельно, последовательно или асинхронно 

Тут введем понятие "фокус" (AudioFocus)  — право приложения перетащить большую часть аудио-внимания на себя 


Допустим, вы проигрываете музыку. Тут другое приложение заявляет, что хочет сместить фокус на себя. Вы можете выбрать один из путей: 

• замолчать - выключите свою музыку, пускай заиграет другое приложение
например, пользователь открыл видео на ютубу - мы ему больше не нужны 

• приглушиться - ваша музыка продолжит играть, но тише.
например, пришло уведомление - нашу музыку приглушаем на секунду, чтобы пользователь услышал "дзынь" от пуша 

• забить - пускай пользователь слушает оба потока одновременно, его проблемы

• замолчать, но автоматически вернуться
например, пользователь начал слушать голосовое в вк - выключаем нашу музыку, а как голосовое закончится - включаемся заново


все эти махинации разруливаются через AudioManager.OnAudioFocusChangeListener, в который система будет кидать флаг состояние фокуса

.... 

это единственная область в андроиде, где приложения могут поднасрать друг другу. ведите себя культурно)</p>
        </a>
      </div>

<div class="container_post">
        <a href="https://t.me/dolgo_polo_dev/39">
          <img class="post_img" src="imgs/39.jpg" onerror="this.src='imgs/not_found.png';">
          <h4 class="post_title"><b>​​Editable vs String</b></h4>
          <p class="post_desc">
• String - класс из Java
• Editable - интерфейс из Android SDK

• String - неизменяем в размере (все операции, меняющие размер строки, на самом деле создают новую строку)
• Editable - позволяет работать с массивом символов динамической длины

• String - хранит только символы
• Editable - хранит символы и их разметку (цвет, размер, стиль ≈ Spannable)

Editable активно используют EditText и TextView

Точнее в них используется имплементация Editable — SpannableStringBuilder, которая помимо всего прочего обеспечивает взаимодействие с интерфейсом TextWatcher (afterTextChanged() - beforeTextChanged() - onTextChanged())

....

бываю ли кейсы, когда стоит самому имплементировать Editable или хотя бы использовать его в местах, не связанных с EditText\TextView?</p>
        </a>
      </div>

<div class="container_post">
        <a href="https://t.me/dolgo_polo_dev/42">
          <img class="post_img" src="imgs/42.jpg" onerror="this.src='imgs/not_found.png';">
          <h4 class="post_title"><b>​​Java vs Kotlin </b></h4>
          <p class="post_desc">#очевидные_вещи 

Нужно ли знать Java? - нужно, так как
 
на Kotlin активно пишут только последние 3 года 
все сотни тысяч строк проектов, на которых вы будете работать, и библиотек, которые затащите в свой проект, будут написаны на Java 
от них не удастся изолироваться, придется понимать, как оно работает

то же касается и обучения — множество важных  статей написано на Java и никто их переписывать не будет


Почему переходят на Kotlin?

• он короче (можно сделать то же, что сделает Java-код, но меньшим количеством строк-символов) 
• он напичкан разными фишками, которые ускоряют разработку
меньше кода - больше профита - разработчикам легче - бизнесу меньше платить за часы программиста
• все новые фишки завязаны на нём - мультиплатформенность, корутины с асинхронностью, compose и т. д.
нет, не котлин все это изобрел, но сейчас развивается это на нем
• google решил поддержать Kotlin. а если компания такого уровня решает сделать технологию базовой - придется с технологией считаться


Лучше Kotlin или Java?

а мы тут не философствовать собрались. закиньте этот вопрос в любой чатик и получите две тысячи аргументом за обе щеки


Можно ли начать с изучения Kotlin?
 
можно. языки схожи, разницы относительно немного


Найду ли работу, зная только Kotlin? 

в маленьком стартапе - да, в других местах - нет
и в любом случае тебя жизнь заставит начать читать Java-код


Как понять, что знаю язык достаточно для поиска работы?

никак. углубляться в язык можно бесконечно. 
но для начала достаточно, если твоих знаний хватает, чтобы решить тз, которое ставит работодатель 
(насколько качественным получится результат - вопрос совсем другой)</p>
        </a>
      </div>

<div class="container_post">
        <a href="https://t.me/dolgo_polo_dev/43">
          <img class="post_img" src="imgs/43.jpg" onerror="this.src='imgs/not_found.png';">
          <h4 class="post_title"><b>​​Где хранится Bundle во время уничтожения / Когда работает onSaveInstanceState()</b></h4>
          <p class="post_desc">
onSaveInstanceState() — вызывается, только когда Activity уничтожается по инициативе системы, а не юзера

вызывается, когда активити уничтожена из-за:
• поворота экрана
• нехватки памяти
• смены языка
• других системных событий, требующих пересоздания\временного уничтожения активити

не вызывается:
• если пользоваться ушел с экрана кнопкой "назад"
• пользователь закрыл приложение

Bundle — объект-мапа, хранящий информацию в виде "ключ-значение"

Bundle на время пересоздания активити записывается в объект ActivityRecord, отвечающий за хранение информации о нашей активити

ActivityRecord в свою очередь связан через Task c ActivityManagerService.... нормальному человеку эти тонкости знать уже не надо)

В конечном итоге Bundle сериализуется (превращается в строку) и записывается на диск (а не остается в оперативке)

...,

в Bundle нельзя сохранять тяжелые данные. но почему?

чем отличается onCreate(Bundle state) от onRestoreInstanceState(Bundle state)?</p>
        </a>
      </div>

<div class="container_post">
        <a href="https://t.me/dolgo_polo_dev/45">
          <img class="post_img" src="imgs/45.jpg" onerror="this.src='imgs/not_found.png';">
          <h4 class="post_title"><b>​​Package Name != Application ID</b></h4>
          <p class="post_desc">
Я был уверен, что Play Market использует имя пакета для аутентификации приложения ⇒ изменять пакет после публикации нельзя. Это не так

• package name — имя папок, в которых лежит проект. используется для
  • сборки проекта
  • расположения генерируемых файлов (например, com.dick.test.R) 
  • доступа к классам через точку (например, .MainActivity = com.dick.test.MainActivity)

следовательно, package name, прописанный в манифесте, должен обязательно совпадать с реальным названием папок

• applicationId — уникальный айдишник приложения

прописывается в buiild.gradle → android →  defaultConfig

используется во всех местах, где просят прописать package name приложения — например, в Play Market и Firebase Console

даже Context.getPackageName() возвращает application id, а не package name... не спрашивайте почему

....

но есть еще интересный факт: после сборки apk в манифест приложения в поле package зашивается applicationId</p>
        </a>
      </div>

<div class="container_post">
        <a href="https://t.me/dolgo_polo_dev/46">
          <img class="post_img" src="imgs/46.jpg" onerror="this.src='imgs/not_found.png';">
          <h4 class="post_title"><b>​​Ставим несколько клик-листенеров на разные буквы TextView </b></h4>
          <p class="post_desc">
Иногда возникает потребность отобразить сплошной текст, в котором будет несколько ссылок 

Можно:

• повесить OnTouchListener и вычислять координату каждой буквы по тапу — но это больше похоже на лайфхаки из тик-тока а-ля "что делать, если сверху кружка запаяна, а снизу в ней дырка"

• засунуть в проект библиотеку с FlowLayout (а-ля LinearLayout, но с автоматическим переносом вьюх на следующую строчку) и запихать в него отдельные TextView для каждого слова — но не надо

А можно сделать быстро и встроенными средствами:

1. создаем для каждой ссылки отдельный SpannableString

2. на каждый SpannableString вешаем свой ClickableSpan(), содержащий колбэк onClick()

3. собираем все SpannableString через  SpannableStringBuilder и передаем его через textView.setText(builder)

4. меняем textView.movementMethod = LinkMovementMethod, чтобы TextView научилась обрабатывать касания на отдельные участки

5. ставим цвет ссылок с помощью textView.linkTextColor = color

готово, нажатия на определенные символы будет выполнять разные действия

....

по совету читателей решил приводить небольшие куски кода - ссылки буду оставлять в комментариях</p>
        </a>
      </div>

<div class="container_post">
        <a href="https://t.me/dolgo_polo_dev/47">
          <img class="post_img" src="imgs/47.jpg" onerror="this.src='imgs/not_found.png';">
          <h4 class="post_title"><b>​​Как по hashCode определяется позиция</b></h4>
          <p class="post_desc">
Вероятно, все слышали, что есть структуры данных, в которых позиция, на которой будет храниться элемент, определяется его hashCode

Но hashCode — это Integer, значит, в таких структурах как HashMap, должен лежать массив длиной 2^32 ? 

Нет, делается немного хитрее (на примере HashMap):

1. создается массив определенного размера например, arr.length = 16

2. когда наступает момент добавить новый элемент, вычисляется его хэш (хэш ключа). например, hashCode = 200

3. вычисляется позиция, на которую нужно положить элемент = hashCode % arr.length  = 200 % 16 = 8

4. на позиции 8 создается массив. в него добавляется наш элемент

5. когда следующий элемент попадает на позицию 8, наш первый элемент сохраняет на него ссылку

да, мы получили массив связанных списков
да, нам теперь плевать на коллизии

дальше можно подумать, как эту систему балансировать, изменяя размер arr.length

....

есть ли другие подходы к сохранению данных, с вычислением позиции через hashCode элемента?</p>
        </a>
      </div>

<div class="container_post">
        <a href="https://t.me/dolgo_polo_dev/48">
          <img class="post_img" src="imgs/48.jpg" onerror="this.src='imgs/not_found.png';">
          <h4 class="post_title"><b>​​Когда не нужно заменять HashMap на ArrayMap </b></h4>
          <p class="post_desc">
Думаю, все в курсе — если попробовать использовать HashMap, студия предложит заменить тип на ArrayMap 

Почему (короткий ответ) — ArrayMap оптимизирован под Android 

Почему (правильный ответ) —

HashMap для каждой пары ключ-значение создаёт объект Map.Entry, который хранит ключ, значение, хэш ключа, ссылку на следующий объект

Такая сложность нужна, так как HashMap хранит данные в массиве массивов (см. "связанные посты" в комментариях)

Но даже пустой объект весит n-байт, а тут столько побочной информации

Поэтому ArrayMap реализует другой подход: он содержит два массива - один mArray для keys и objects, второй mHashes для хэша ключей
Процесс добавления новой пары: 

1. в mArray кладется ключ
2. на следующую позицию в mArray кладется объект
3. вычисляется hash от ключа и кладется в mHashes

Вывод: в HashMap поиск по ключу быстрее, но ArrayMap съедает в разы меньше памяти

....

А зачем тогда SparseArray?

Бывали ли у вас ситуации, когда правильный выбор структуры давал заметный прирост к производительности или андроид-разработчику в реальности такие знания не пригождаются?</p>
        </a>
      </div>

<div class="container_post">
        <a href="https://t.me/dolgo_polo_dev/49">
          <img class="post_img" src="imgs/49.jpg" onerror="this.src='imgs/not_found.png';">
          <h4 class="post_title"><b>​​с наступившим, работяги!</b></h4>
          <p class="post_desc">желаю отдохнуть от работы, учебы, самообразования и всего, от чего хочется отдохнуть, чтобы взяться за все это с новыми силами и получить новые успехи</p>
        </a>
      </div>

<div class="container_post">
        <a href="https://t.me/dolgo_polo_dev/50">
          <img class="post_img" src="imgs/50.jpg" onerror="this.src='imgs/not_found.png';">
          <h4 class="post_title"><b>​​Концепция InputStream - Reader - Buffered</b></h4>
          <p class="post_desc">
С понятием InputStream мобильный разработчик сталкивается, когда нужно прочитать локальный файл или загрузить его по ссылке

Общая логика считывания больших объемов данных (или данных неизвестного размера) следующая:

• InputStream (все его реализации) — класс, позволяющий обозначить источник данных (файл, ссылка, массив байтов...) и начать считывать его байт за байтом

• Reader (все его реализации) — класс, преобразующий байты, считываемые при помощи InputStream, в символы по заданной таблице кодирования (например, Unicode)

• Buffered  (все его реализации) — класс, позволяющий ускорить процесс чтения за счет буферизации источника данных

Зачем буфер: если мы читаем файл с жесткого диска, то каждая операция запроса и переноса байтов с самого диска в оперативку занимает много времени. Потому нашей программе лучше за одно обращение считать n-байтов, а не один. Это справедливо для сетевых запросов

Комбинация реализаций позволяет считать данные в нужном формате и с оптимальными настройками буферизации

Та же самая история справедлива и для отдачи байтов: OutputStream - Writer - Buffered

....

загадка: по какой таблице кодирования Reader/Writer сопоставит байты и символы? откуда он ее возьмет - зашита в Java, определена в Android, задается JVM...?</p>
        </a>
      </div>

<div class="container_post">
        <a href="https://t.me/dolgo_polo_dev/51">
          <img class="post_img" src="imgs/51.jpg" onerror="this.src='imgs/not_found.png';">
          <h4 class="post_title"><b>​​Kotlin Coroutine. Suspend — зачем и как?</b></h4>
          <p class="post_desc">
suspend — ключевое слово, которое говорит компилятору о том, что в функцию нужно добавить (и передать при вызове) аргумент типа Continuation

Continuation — интерфейс, который содержит одну функцию resumeWith(result: Result<T>). то есть обычный колбэк 

когда suspend-функция выполнила работу, она должна вызвать continuation.resumeWith(result)

если она этого не сделает, то корутина, вызвавшая эту suspend-функцию, просто зависнет

после вызова колбэка, корутина, запустившая suspend-функцию, получит результат (если функция обещала что-то вернуть) и продолжит работу

примечание: разработчику самому нужно вызывать continuation.resumeWith(result) только когда он использует suspendCoroutine { ... }. в остальных корутин-билдерах оно вызывается самостоятельно под капотом

Выводы:

• suspend само по себе не делает функцию асинхронной, только добавляет параметр при компиляции

если вы на функцию поставите клеймо suspend, но долгие операции, выполняемые в ней, не вынесите в отдельный поток, то асинхронность не случится


• suspend-функцию можно вызвать только из корутины (или другой suspend-функции)

потому что Continuation — это объект, который создается в корутине и передается suspend-функциям внутри нее</p>
        </a>
      </div>

<div class="container_post">
        <a href="https://t.me/dolgo_polo_dev/52">
          <img class="post_img" src="imgs/52.jpg" onerror="this.src='imgs/not_found.png';">
          <h4 class="post_title"><b>​​sealed interface vs sealed class vs enum</b></h4>
          <p class="post_desc">
enum:

• в первую очередь - это перечисление. поэтому у него есть методы для перебора значений

• у каждой константы перечисления есть только параметры, описанные в конструкторе родительского enum

• у каждого константы перечисления есть только функции, объявленные как abstract или определенные в родительском enum

• каждое константы перечисления - object, то есть имеет один экземпляр

• реализует serializable (удобно сохранять\отправлять как строку) и comporable (непонятно зачем)


sealed:

• в первую очередь - обычный класс

• каждый из наследников может иметь свой конструктор, свои функции

• наследниками могут быть как object, так и class
следовательно, наследники-классы могут существовать в нескольких экземплярах

• в отличие от обычных open-классов, все наследники sealed класса должны быть определены до компиляции
то есть sealed что-то среднее между open и final-классами


sealed class или sealed interface:

• class - если хочешь создать переменную в конструкторе\внутри класса

• interface - если переменные не нужны\достаточно констант в companion object

....

в каких конкретно кейсах вы используете sealed, а в каких enum?</p>
        </a>
      </div>

        </div>

        <div id="footer"></div>

    </div>

    <div id="b_open_random_post">открыть<br> рандом<br>ный<br> пост</div>


</body>

<script type="text/javascript">
  document.getElementById("logo").addEventListener("click", function(){ window.open("https://t.me/dolgo_polo_dev"); });

  const input = document.getElementById("input")
  document.getElementById("b_clear").addEventListener("click", function(){ 
    filter("")
    input.value = "";
});

  var postUrls =
["https://t.me/dolgo_polo_dev/14","https://t.me/dolgo_polo_dev/15","https://t.me/dolgo_polo_dev/18","https://t.me/dolgo_polo_dev/19","https://t.me/dolgo_polo_dev/20","https://t.me/dolgo_polo_dev/21","https://t.me/dolgo_polo_dev/22","https://t.me/dolgo_polo_dev/23","https://t.me/dolgo_polo_dev/24","https://t.me/dolgo_polo_dev/25","https://t.me/dolgo_polo_dev/26","https://t.me/dolgo_polo_dev/27","https://t.me/dolgo_polo_dev/29","https://t.me/dolgo_polo_dev/30","https://t.me/dolgo_polo_dev/31","https://t.me/dolgo_polo_dev/32","https://t.me/dolgo_polo_dev/33","https://t.me/dolgo_polo_dev/34","https://t.me/dolgo_polo_dev/35","https://t.me/dolgo_polo_dev/39","https://t.me/dolgo_polo_dev/42","https://t.me/dolgo_polo_dev/43","https://t.me/dolgo_polo_dev/45","https://t.me/dolgo_polo_dev/46","https://t.me/dolgo_polo_dev/47","https://t.me/dolgo_polo_dev/48","https://t.me/dolgo_polo_dev/49","https://t.me/dolgo_polo_dev/50","https://t.me/dolgo_polo_dev/51","https://t.me/dolgo_polo_dev/52"];
  document.getElementById("b_open_random_post").addEventListener("click", function(){
    var url = postUrls[Math.floor(Math.random()*postUrls.length)];
    window.open(url);
});

  input.addEventListener('input', function(e) { 
    filter(e.target.value.toLowerCase())
});

  function filter(inputValue) {
   const divs = document.getElementById("container_posts").getElementsByTagName('div');
   for(i = 0; i < divs.length; i++) {
       const firstChild = divs[i].children[0];
       const title = firstChild.children[1];
       const text = title.textContent.toLowerCase();

       const desc = firstChild.children[2];
       const descText = desc.textContent.toLowerCase();

       if(text.includes(inputValue) || descText.includes(inputValue) || inputValue == "") {
        divs[i].style.display = 'block';
    } else {
        divs[i].style.display = 'none';
    }
}
}


</script>

</html>
